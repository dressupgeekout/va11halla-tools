#!/usr/bin/env ruby
#
# Copyright (c) 2019-2025 Charlotte Koch. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#   1. Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#
#   2.  Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

require 'optparse'

$LOAD_PATH.unshift File.join(__dir__, "..", "lib")
require 'va11halla'

########## ########## ##########

PROGNAME = File.basename($0)

extract = true
specific_chunk = nil
debug = false
want_version = false
outdir = File.expand_path(".")

parser = OptionParser.new do |opts|
  opts.banner = "usage: #{PROGNAME} [options] data-file"
  opts.on("--no-extract", "Don't extract any files, only list info") { extract = false }
  opts.on("--chunk NAME", "Operate only on the given chunk") { |name| specific_chunk = name }
  opts.on("-d", "--debug") { debug = true }
  opts.on("-h", "--help", "Show this help message") { puts opts.to_s; exit 0 }
  opts.on("-o", "--output-dir PATH", "Location to extract files") { |dir|
    outdir = File.expand_path(dir)
  }
  opts.on("--version", "Show version information") { want_version = true }
end

parser.parse!(ARGV)

if want_version
  puts "#{PROGNAME} #{Va11halla::VERSION}"
  exit 0
end

specific_chunk.upcase! if specific_chunk

path = ARGV.shift

if not path
  $stderr.puts(parser.to_s)
  exit 1
end

path = File.expand_path(path)

if not File.file?(path)
  $stderr.puts("#{PROGNAME}: no such file #{path.inspect}")
  exit 1
end

begin
  Dir.chdir(outdir)
rescue Errno::ENOENT => err
  $stderr.puts("#{PROGNAME}: could not change into output directory: #{err}")
  exit 1
end

data = Va11halla::IFF.new(path)
data.open

data.parse(**{
  :specific_chunk => specific_chunk,
  :debug => debug,
})

if debug
  puts "Total length: #{data.total_length}"
end

if extract
  # Extract TXTRs.
  if specific_chunk == "TXTR" || specific_chunk.nil?
    data.txtr_infos.each do |ti|
      puts("writing #{ti.filename}")
      data.fp.seek(ti.location)
      File.open(ti.filename, 'wb') { |fp| fp.write(data.fp.read(ti.size)) }
    end
  end

  # Extract AUDOs.
  if specific_chunk == "AUDO" || specific_chunk.nil?
    data.audo_infos.each do |ai|
      data.fp.seek(ai.location)
      filename = data.sond_infos[ai.index].filename
      puts("writing #{filename}")
      File.open(filename, 'wb') { |fp| fp.write(data.fp.read(ai.size)) }
    end
  end

  # Extract SHDRs.
  if specific_chunk == "SHDR" || specific_chunk.nil?
    data.shdr_infos.each_with_index do |si|
      si.data.each do |datum|
        data.fp.seek(datum[:location])
        puts "writing #{datum[:filename]}"
        File.open(datum[:filename], "wb") { |fp| fp.puts(data.fp.read(datum[:size])) }
      end
    end
  end

  # Extract STRGs.
  #
  # Don't create 1 file per string. Instead, we combine them all into a
  # giant array and write a single file.
  if specific_chunk == "STRG" || specific_chunk.nil?
    all_strings = data.strg_infos.map { |si| si.string }
    filename = "STRG.yaml"
    puts "writing #{filename}"
    File.open(filename, "w") { |fp| fp.puts(YAML.dump(all_strings)) }
  end
end

data.close

if debug
  puts "Chunk counts:"
  data.chunk_counts.each do |name, count|
    puts "  #{name} #{count}"
  end

  puts

  puts "Section lengths:"
  data.section_lengths.sort_by { |k, v| k }.each do |name, len|
    puts "  #{name} #{len} B == #{len/1024} KB"
  end

  puts

  puts "Font infos:"
  data.font_infos.each do |fi|
    puts("  #{fi}")
  end

  puts

  puts "Sond infos:"
  data.sond_infos.each do |si|
    puts("  #{si}")
  end

  puts

  puts "Audo infos:"
  data.audo_infos.each do |ai|
    puts("  #{ai}")
  end

  puts

  puts "AGRPs:"
  data.agrps.each do |agrp|
    puts("  - #{agrp}")
  end

  puts

  puts "Sprt infos:"
  data.sprt_infos.each do |si|
    puts("  #{si}")
    si.frames.each do |frame|
      puts("    #{frame}")
    end
    puts
  end

  puts

  puts "Shdr infos:"
  data.shdr_infos.each do |si|
    puts("  #{si}")
  end

  puts

  puts "Tpag infos:"
  data.tpag_infos.each do |ti|
    puts("  #{ti}")
  end

  puts

  puts "Code infos:"
  data.code_infos.each do |ci|
    puts("  #{ci}")
  end

  puts

  puts "Vari infos:"
  data.vari_infos.each do |vi|
    puts("  #{vi}")
  end

  puts

  puts "Txtr infos:"
  data.txtr_infos.each do |ti|
    puts "  #{ti}"
  end
end
